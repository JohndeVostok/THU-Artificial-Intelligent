# 四子棋游戏 实验报告

马子轩 计研22 2019211119

### 一、实验要求

以C/C++实现四子棋游戏的策略。

四子棋游戏的规则如下：

1. 棋盘的行数与列数为随机生成的9~12的整数

2. 双方交替下棋，每次选择一个非空列落子，棋子会落到该列最下方的空格
3. 横竖或斜向先连4字为胜
4. 会随机一个点不可落子

要求编写策略函数，选择每个局面的落子点


### 二、理论分析

我们使用蒙特卡洛树搜索的方法来进行四子棋。

蒙特卡洛算法本质上是通过尝试去逼近模拟值的一种方法，在这个场景下，蒙特卡洛搜索树也是相似的道理。通过模拟棋局的方式，统计每个操作的胜率，从而实现策略。

我们把局面状态的变化过程组织成一棵树，叫做状态树，那么显然，所有叶节点都是分出胜负的状态。那么我们定义一次尝试，是从一个状态节点到叶节点的路径。一次模拟的最终状态，会在这一条路径种给出统计值，包括次数和积分。这个过程我们叫做rollout。那么我们在进行决策的时候，选择当前局面下胜率最高的就是一种合适的策略。

在一次rollout中，面临一个问题，在每个状态下，如何选择下一步棋。我们的策略是这样，首先，优先选择没有被探索过的子状态。在所有子状态都被探索过的情况下，我们需要综合胜率和探索次数进行选择。这种情况我们引入UCB:

UCB = vi + c * sqrt(logN / ni)

其中，vi表示这个状态的评分，例如胜率。N表示总探索数，ni表示子状态探索数。那么左项能够提高高胜率选择概率，而右项能提高探索没有被探索局面的能力。c表示置信度，置信度95%的时候c取值为1.96。
我们在所有子状态都被探索的情况下，会根据UCB来分配不同子节点被选择的概率。

当访问到叶节点的时候，该状态的胜负被记录，并返回到他的父亲节点，被统计，这个过程叫做反向传播。

经过若干次rollout后，我们得到了一个局面的所有子状态的统计值，也就是胜率，这种情况下我们就可以决策了。


### 三、实现过程

我们基于C/C++实现了MCTS算法。

首先是状态树的设计，我们对每个状态做hash，然后使用一个unordered_map存储状态空间的统计信息。hash函数我们使用了zobrist hash。

zobrist hash的原理很简单，在棋盘上，每个棋子可能属于2方，棋盘有2维坐标。那么我们生成M * N * 2个随机数，表示一方落在某个坐标。那么整个状态的hash就是每个落子的状态之和。首先，这个hash实现性能比较好，只需要扫一遍图即可。同时，很适合棋局的状态，并不容易碰撞。这种方法优于直接进行编码。

在每次决策中，我们会进行5000次rollout，受限于saibo网站上的实现要求，我们不能够使用GPU或多线程CPU，因此并不容易实现基于神经网络的方案。

在策略选择中，我们对随机性进行了一些折衷，在前5步，我们会根据胜率，按照概率选择落子点，在5步之后，我们每次选择胜率最高的落子。这样会带来一定的探索性，提高了10%的胜率。

rollout过程中，我们按照UCB的方式进行状态选择，这一部分没有太多的额外设计。

我们的文件组织同给出的文件完全一致，只修改了Strategy.h和Strategy.cpp，因此不做更多赘述。

### 实验结果

我们的最终版本实现在针对实验给定的50个测例的对抗中，71胜，29负，0平

### 总结与展望

实际在实验过程中，我们可以讲UCB替换为神经网络进行实验，这样可能会带来更好的效果，然而，我们遇到的问题是，saibo的提交可能不能使用GPU代码，因此实现效率可能会成为严重问题。这也是后续可以做的工作。


